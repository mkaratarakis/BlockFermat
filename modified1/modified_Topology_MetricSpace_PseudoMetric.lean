def UniformSpace.ofDist (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_self : ‚àÄ x : Œ±, dist x x = 0)
    (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z) : UniformSpace Œ± :=
  .ofFun dist dist_self dist_comm dist_triangle ofDist_aux
#align uniform_space_of_dist UniformSpace.ofDist

def Bornology.ofDist {Œ± : Type*} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_comm : ‚àÄ x y, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z, dist x z ‚â§ dist x y + dist y z) : Bornology Œ± :=
  Bornology.ofBounded { s : Set Œ± | ‚àÉ C, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C }
    ‚ü®0, fun x hx y => hx.elim‚ü© (fun s ‚ü®c, hc‚ü© t h => ‚ü®c, fun x hx y hy => hc (h hx) (h hy)‚ü©)
    (fun s hs t ht => by
      rcases s.eq_empty_or_nonempty with rfl | ‚ü®x, hx‚ü©
      ¬∑ rwa [empty_union]
      rcases t.eq_empty_or_nonempty with rfl | ‚ü®y, hy‚ü©
      ¬∑ rwa [union_empty]
      rsuffices ‚ü®C, hC‚ü© : ‚àÉ C, ‚àÄ z ‚àà s ‚à™ t, dist x z ‚â§ C
      ¬∑ refine ‚ü®C + C, fun a ha b hb => (dist_triangle a x b).trans ?_‚ü©
        simpa only [dist_comm] using add_le_add (hC _ ha) (hC _ hb)
      rcases hs with ‚ü®Cs, hs‚ü©; rcases ht with ‚ü®Ct, ht‚ü©
      refine ‚ü®max Cs (dist x y + Ct), fun z hz => hz.elim
        (fun hz => (hs hx hz).trans (le_max_left _ _))
        (fun hz => (dist_triangle x y z).trans <|
          (add_le_add le_rfl (ht hy hz)).trans (le_max_right _ _))‚ü©)
    fun z => ‚ü®dist z z, forall_eq.2 <| forall_eq.2 le_rfl‚ü©
#align bornology.of_dist Bornology.ofDist‚Çì

def PseudoMetricSpace.ofDistTopology {Œ± : Type u} [TopologicalSpace Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
    (dist_self : ‚àÄ x : Œ±, dist x x = 0) (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z)
    (H : ‚àÄ s : Set Œ±, IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s) :
    PseudoMetricSpace Œ± :=
  { dist := dist
    dist_self := dist_self
    dist_comm := dist_comm
    dist_triangle := dist_triangle
    edist_dist := fun x y => by exact ENNReal.coe_nnreal_eq _
    toUniformSpace :=
      (UniformSpace.ofDist dist dist_self dist_comm dist_triangle).replaceTopology <|
        TopologicalSpace.ext_iff.2 fun s ‚Ü¶ (H s).trans <| forall‚ÇÇ_congr fun x _ ‚Ü¶
          ((UniformSpace.hasBasis_ofFun (exists_gt (0 : ‚Ñù)) dist dist_self dist_comm dist_triangle
            UniformSpace.ofDist_aux).comap (Prod.mk x)).mem_iff.symm
    uniformity_dist := rfl
    toBornology := Bornology.ofDist dist dist_comm dist_triangle
    cobounded_sets := rfl }
#align pseudo_metric_space.of_dist_topology PseudoMetricSpace.ofDistTopology

def evalDist : PositivityExt where eval {u Œ±} _zŒ± _pŒ± e := do
  match u, Œ±, e with
  | 0, ~q(‚Ñù), ~q(@Dist.dist $Œ≤ $inst $a $b) =>
    let _inst ‚Üê synthInstanceQ q(PseudoMetricSpace $Œ≤)
    assertInstancesCommute
    pure (.nonnegative q(dist_nonneg))
  | _, _, _ => throwError "not dist"

end Mathlib.Meta.Positivity

example {x y : Œ±} : 0 ‚â§ dist x y := by positivity

@[simp] theorem abs_dist {a b : Œ±} : |dist a b| = dist a b := abs_of_nonneg dist_nonneg
#align abs_dist abs_dist

def ball (x : Œ±) (Œµ : ‚Ñù) : Set Œ± :=
  { y | dist y x < Œµ }
#align metric.ball Metric.ball

def closedBall (x : Œ±) (Œµ : ‚Ñù) :=
  { y | dist y x ‚â§ Œµ }
#align metric.closed_ball Metric.closedBall

def sphere (x : Œ±) (Œµ : ‚Ñù) := { y | dist y x = Œµ }
#align metric.sphere Metric.sphere

def PseudoMetricSpace.replaceUniformity {Œ±} [U : UniformSpace Œ±] (m : PseudoMetricSpace Œ±)
    (H : ùì§[U] = ùì§[PseudoEMetricSpace.toUniformSpace]) : PseudoMetricSpace Œ± :=
  { m with
    toUniformSpace := U
    uniformity_dist := H.trans PseudoMetricSpace.uniformity_dist }
#align pseudo_metric_space.replace_uniformity PseudoMetricSpace.replaceUniformity

def PseudoMetricSpace.replaceTopology {Œ≥} [U : TopologicalSpace Œ≥] (m : PseudoMetricSpace Œ≥)
    (H : U = m.toUniformSpace.toTopologicalSpace) : PseudoMetricSpace Œ≥ :=
  @PseudoMetricSpace.replaceUniformity Œ≥ (m.toUniformSpace.replaceTopology H) m rfl
#align pseudo_metric_space.replace_topology PseudoMetricSpace.replaceTopology

def PseudoEMetricSpace.toPseudoMetricSpaceOfDist {Œ± : Type u} [e : PseudoEMetricSpace Œ±]
    (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (edist_ne_top : ‚àÄ x y : Œ±, edist x y ‚â† ‚ä§)
    (h : ‚àÄ x y, dist x y = ENNReal.toReal (edist x y)) : PseudoMetricSpace Œ± where
  dist := dist
  dist_self x := by simp [h]
  dist_comm x y := by simp [h, edist_comm]
  dist_triangle x y z := by
    simp only [h]
    exact ENNReal.toReal_le_add (edist_triangle _ _ _) (edist_ne_top _ _) (edist_ne_top _ _)
  edist := edist
  edist_dist _ _ := by simp only [h, ENNReal.ofReal_toReal (edist_ne_top _ _)]
  toUniformSpace := e.toUniformSpace
  uniformity_dist := e.uniformity_edist.trans <| by
    simpa only [ENNReal.coe_toNNReal (edist_ne_top _ _), h]
      using (Metric.uniformity_edist_aux fun x y : Œ± => (edist x y).toNNReal).symm
#align pseudo_emetric_space.to_pseudo_metric_space_of_dist PseudoEMetricSpace.toPseudoMetricSpaceOfDist

def PseudoEMetricSpace.toPseudoMetricSpace {Œ± : Type u} [PseudoEMetricSpace Œ±]
    (h : ‚àÄ x y : Œ±, edist x y ‚â† ‚ä§) : PseudoMetricSpace Œ± :=
  PseudoEMetricSpace.toPseudoMetricSpaceOfDist (fun x y => ENNReal.toReal (edist x y)) h fun _ _ =>
    rfl
#align pseudo_emetric_space.to_pseudo_metric_space PseudoEMetricSpace.toPseudoMetricSpace

def PseudoMetricSpace.replaceBornology {Œ±} [B : Bornology Œ±] (m : PseudoMetricSpace Œ±)
    (H : ‚àÄ s, @IsBounded _ B s ‚Üî @IsBounded _ PseudoMetricSpace.toBornology s) :
    PseudoMetricSpace Œ± :=
  { m with
    toBornology := B
    cobounded_sets := Set.ext <| compl_surjective.forall.2 fun s =>
        (H s).trans <| by rw [isBounded_iff, mem_setOf_eq, compl_compl] }
#align pseudo_metric_space.replace_bornology PseudoMetricSpace.replaceBornology

def PseudoMetricSpace.induced {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (m : PseudoMetricSpace Œ≤) :
    PseudoMetricSpace Œ± where
  dist x y := dist (f x) (f y)
  dist_self x := dist_self _
  dist_comm x y := dist_comm _ _
  dist_triangle x y z := dist_triangle _ _ _
  edist x y := edist (f x) (f y)
  edist_dist x y := edist_dist _ _
  toUniformSpace := UniformSpace.comap f m.toUniformSpace
  uniformity_dist := (uniformity_basis_dist.comap _).eq_biInf
  toBornology := Bornology.induced f
  cobounded_sets := Set.ext fun s => mem_comap_iff_compl.trans <| by
    simp only [‚Üê isBounded_def, isBounded_iff, forall_mem_image, mem_setOf]
#align pseudo_metric_space.induced PseudoMetricSpace.induced

def Inducing.comapPseudoMetricSpace {Œ± Œ≤} [TopologicalSpace Œ±] [m : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Inducing f) : PseudoMetricSpace Œ± :=
  .replaceTopology (.induced f m) hf.induced
#align inducing.comap_pseudo_metric_space Inducing.comapPseudoMetricSpace

def UniformInducing.comapPseudoMetricSpace {Œ± Œ≤} [UniformSpace Œ±] [m : PseudoMetricSpace Œ≤]
    (f : Œ± ‚Üí Œ≤) (h : UniformInducing f) : PseudoMetricSpace Œ± :=
  .replaceUniformity (.induced f m) h.comap_uniformity.symm
#align uniform_inducing.comap_pseudo_metric_space UniformInducing.comapPseudoMetricSpace

def (f g : ‚àÄ b, œÄ b) : nndist f g = sup univ fun b => nndist (f b) (g b) :=
  NNReal.eq rfl
#align nndist_pi_def nndist_pi_def

def (f g : ‚àÄ b, œÄ b) : dist f g = (sup univ fun b => nndist (f b) (g b) : ‚Ñù‚â•0) :=
  rfl
#align dist_pi_def dist_pi_def

structure from a distance function and metric space axioms -/
def UniformSpace.ofDist (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) (dist_self : ‚àÄ x : Œ±, dist x x = 0)
    (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z) : UniformSpace Œ± :=
  .ofFun dist dist_self dist_comm dist_triangle ofDist_aux
#align uniform_space_of_dist UniformSpace.ofDist

structure and the emetric space structure are embedded in the metric space structure
-- to avoid instance diamond issues. See Note [forgetful inheritance].
/-- This is an internal lemma used inside the default of `PseudoMetricSpace.edist`. -/
private theorem dist_nonneg' {Œ±} {x y : Œ±} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
    (dist_self : ‚àÄ x : Œ±, dist x x = 0) (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z) : 0 ‚â§ dist x y :=
  have : 0 ‚â§ 2 * dist x y :=
    calc 0 = dist x x := (dist_self _).symm
    _ ‚â§ dist x y + dist y x := dist_triangle _ _ _
    _ = 2 * dist x y := by rw [two_mul, dist_comm]
  nonneg_of_mul_nonneg_right this two_pos

#noalign pseudo_metric_space.edist_dist_tac -- Porting note (#11215): TODO: restore

structure whose underlying topological space structure
(definitionally) agrees which a pre-existing topology which is compatible with a given distance
function. -/
def PseudoMetricSpace.ofDistTopology {Œ± : Type u} [TopologicalSpace Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
    (dist_self : ‚àÄ x : Œ±, dist x x = 0) (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
    (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z)
    (H : ‚àÄ s : Set Œ±, IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s) :
    PseudoMetricSpace Œ± :=
  { dist := dist
    dist_self := dist_self
    dist_comm := dist_comm
    dist_triangle := dist_triangle
    edist_dist := fun x y => by exact ENNReal.coe_nnreal_eq _
    toUniformSpace :=
      (UniformSpace.ofDist dist dist_self dist_comm dist_triangle).replaceTopology <|
        TopologicalSpace.ext_iff.2 fun s ‚Ü¶ (H s).trans <| forall‚ÇÇ_congr fun x _ ‚Ü¶
          ((UniformSpace.hasBasis_ofFun (exists_gt (0 : ‚Ñù)) dist dist_self dist_comm dist_triangle
            UniformSpace.ofDist_aux).comap (Prod.mk x)).mem_iff.symm
    uniformity_dist := rfl
    toBornology := Bornology.ofDist dist dist_comm dist_triangle
    cobounded_sets := rfl }
#align pseudo_metric_space.of_dist_topology PseudoMetricSpace.ofDistTopology

structure coming from the edistance and the
distance coincide. -/

-- Porting note (#10756): new theorem

structure is provably
(but typically non-definitionaly) equal to some given uniform structure.
See Note [forgetful inheritance].
-/
@[reducible]
def PseudoMetricSpace.replaceUniformity {Œ±} [U : UniformSpace Œ±] (m : PseudoMetricSpace Œ±)
    (H : ùì§[U] = ùì§[PseudoEMetricSpace.toUniformSpace]) : PseudoMetricSpace Œ± :=
  { m with
    toUniformSpace := U
    uniformity_dist := H.trans PseudoMetricSpace.uniformity_dist }
#align pseudo_metric_space.replace_uniformity PseudoMetricSpace.replaceUniformity

structure is
provably (but typically non-definitionaly) equal to some given topological structure.
See Note [forgetful inheritance].
-/
@[reducible]
def PseudoMetricSpace.replaceTopology {Œ≥} [U : TopologicalSpace Œ≥] (m : PseudoMetricSpace Œ≥)
    (H : U = m.toUniformSpace.toTopologicalSpace) : PseudoMetricSpace Œ≥ :=
  @PseudoMetricSpace.replaceUniformity Œ≥ (m.toUniformSpace.replaceTopology H) m rfl
#align pseudo_metric_space.replace_topology PseudoMetricSpace.replaceTopology

structure is provably
(but typically non-definitionaly) equal to some given bornology structure.
See Note [forgetful inheritance].
-/
@[reducible]
def PseudoMetricSpace.replaceBornology {Œ±} [B : Bornology Œ±] (m : PseudoMetricSpace Œ±)
    (H : ‚àÄ s, @IsBounded _ B s ‚Üî @IsBounded _ PseudoMetricSpace.toBornology s) :
    PseudoMetricSpace Œ± :=
  { m with
    toBornology := B
    cobounded_sets := Set.ext <| compl_surjective.forall.2 fun s =>
        (H s).trans <| by rw [isBounded_iff, mem_setOf_eq, compl_compl] }
#align pseudo_metric_space.replace_bornology PseudoMetricSpace.replaceBornology

structure pulled back by a function. -/
@[reducible]
def PseudoMetricSpace.induced {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (m : PseudoMetricSpace Œ≤) :
    PseudoMetricSpace Œ± where
  dist x y := dist (f x) (f y)
  dist_self x := dist_self _
  dist_comm x y := dist_comm _ _
  dist_triangle x y z := dist_triangle _ _ _
  edist x y := edist (f x) (f y)
  edist_dist x y := edist_dist _ _
  toUniformSpace := UniformSpace.comap f m.toUniformSpace
  uniformity_dist := (uniformity_basis_dist.comap _).eq_biInf
  toBornology := Bornology.induced f
  cobounded_sets := Set.ext fun s => mem_comap_iff_compl.trans <| by
    simp only [‚Üê isBounded_def, isBounded_iff, forall_mem_image, mem_setOf]
#align pseudo_metric_space.induced PseudoMetricSpace.induced

structure by an inducing map. This is a version of
`PseudoMetricSpace.induced` useful in case if the domain already has a `TopologicalSpace`
structure. -/
def Inducing.comapPseudoMetricSpace {Œ± Œ≤} [TopologicalSpace Œ±] [m : PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Inducing f) : PseudoMetricSpace Œ± :=
  .replaceTopology (.induced f m) hf.induced
#align inducing.comap_pseudo_metric_space Inducing.comapPseudoMetricSpace

structure by a uniform inducing map. This is a version of
`PseudoMetricSpace.induced` useful in case if the domain already has a `UniformSpace`
structure. -/
def UniformInducing.comapPseudoMetricSpace {Œ± Œ≤} [UniformSpace Œ±] [m : PseudoMetricSpace Œ≤]
    (f : Œ± ‚Üí Œ≤) (h : UniformInducing f) : PseudoMetricSpace Œ± :=
  .replaceUniformity (.induced f m) h.comap_uniformity.symm
#align uniform_inducing.comap_pseudo_metric_space UniformInducing.comapPseudoMetricSpace